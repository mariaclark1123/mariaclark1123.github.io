<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
<title>OpenGL - Z-Buffer Algorithm</title>
<link rel="stylesheet" href="css/style.css">
</head>

<body>
<div class="container">
<hr>
<h1>OpenGL - Z-Buffer Algorithm</h1>
<hr>
<br>

<p>The z-Buffer algorithm is one of the most commonly used routines. It is simple, easy to implement, and is often found in hardware.</p> 
<p>The idea behind it is uncomplicated: Assign a z-value to each polygon and then display the one (pixel by pixel) that has the smallest value.</p>
<br>
<hr>
<br>
<h3>Advantages:</h3>
    <ul>
        <li>Simple to use</li>
        <li>Can be implemented easily in object or image sapce</li>
        <li>Can be executed quickly, even with many polygons</li>
    </ul>
        <br>
        <h3>Disadvantages:</h3>
    <ul>
        <li>Takes up a lot of memory</li>
        <li>Can't do transparent surfaces without additional code</li>
    </ul>
        <br>
        <hr>
        <br>
        <h3>For example:</h3>
        <div class = "clearfix"><img align=left src="example4.gif"></div>
        <div class = "clearfix"><img align=left src="example5.gif"></div>
        <p>Consider these two polygons (left:head-on, right:edge-on)</p>
        <p>The computer would start (arbitrarily) with Polygon 1 and put it's depth value into the buffer. It would do the same for the next polygon, P2. It will then check each overlapping pixel and check to see which one is closer to the viewer, and display the appropriate color.</p>
        <br>
        <p> This is a simplistic example, but the basic ideas are valid for polygons in any orientation and permutation (this algorithm will properly display polygons piercing one another, and polygons with conflicting depths, such as:</p>
        <br>
        <div class="clearfix"><img align=left src="example6.gif"></div>
        <br>
    </div>
</body>
</html>
