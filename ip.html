<!DOCTYPE html>

<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no" />
    <title></title>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <div class="container">
        <hr>
        <h1>静态IP和动态IP</h1>
        <hr>
        <br>
        <p>
            态IP，即IP位址会随着电脑的开关机，或ISP重新分配的IP地址而变动。
        </p>
        <br>
        <p>
            在网络上，每台电脑之间都是通过IP地址来通讯，也就是说，不管是连接网络，还是传送邮件，都必须知道对方的IP地址才能和对方的机器连通。而IP地址都是数字(EX：123.123.123.123)。固定IP即是ISP(Internet Service Provider, 互联网服务提供商)给用户的固定IP地址，不会变动，适合用作网站建设。一般使用户适合使用动态IP，即IP位址会随着电脑的开关机，或ISP重新分配的IP地址而变动。</p>
        <p>
            动态IP的出现有几个原因，第一、IP不夠用，第二、自己随便设置的话容易和別人设置的IP地址产生冲突，第三、使用NB不就每換地方就得改設定。所以伺服主機和網路設備多使用固定IP。
        </p>

        <br>
        <p>
            动态IP：網際網路上，每台電腦之間，是透過IP位址來通訊。也就是說，不管是要連上網路，或是傳送信件，都必須知道對方的IP位址才能與該台電腦溝通。而IP位址都是數字(EX：123.123.123.123)。固定IP即ISP業者給予用戶固定的IP位址，不會變動，適合架設網站。一般使用戶較適合浮動IP，意即IP位址會隨電腦開、關機，或ISP業者重新發派IP位址而異動。為什麼需要用浮動IP？ 第一、IP不夠用，第二、你隨便設，和別人衝突機會高，第三、使用NB不就每換地方就得改設定。所以伺服主機和網路設備多使用固定IP。
        </p>
        <p>
            浮動IP優缺點：
        </p>
        <ul>
            <li> 1.用戶可以僅申請一條ADSL或Cable即可讓多人一同上網。</li>
            <li> 2. glBindBufferARB(GL_ARRAY_BUFFER_ARB, nVBOVertices); //声明该句柄为一个vbo句柄，并选择之 </li>
            <li> 3. glBufferDataARB(GL_ARRAY_BUFFER_ARB, sizeof(vertices), vertices, GL_STATIC_DRAW); //将顶点集上传至server端</li>
        </ul>
            <br>

            <p>
                初始化阶段：
            </p>
            <ul>
                <li> 1. glGenBuffersARB(1, &nVBOVertices); //生成一个句柄</li>
                <li> 2. glBindBufferARB(GL_ARRAY_BUFFER_ARB, nVBOVertices); //声明该句柄为一个vbo句柄，并选择之 </li>
                <li> 3. glBufferDataARB(GL_ARRAY_BUFFER_ARB, sizeof(vertices), vertices, GL_STATIC_DRAW); //将顶点集上传至server端</li>

                <br>
                <p>
                    使用阶段：
                </p>
                <li> 1. glEnableClientState(GL_VERTEX_ARRAY); //开始使用vbo</p>
                <li> 2. glBindBufferARB(GL_ARRAY_BUFFER_ARB, nVBOVertices); //选择当前使用的vbo </li>
                <li> 3. glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)); //指定vbo顶点格式</li>
                <li> 4. glDrawArrays( GL_TRIANGLES, 0, g_pMesh->m_nVertexCount ); //画吧 </li>
                <li> 5. glDisableClientState(GL_VERTEX_ARRAY); //停止使用vbo </li>
            </ul>
            <br>
            <p>
                收尾阶段：
            </p>
            <ul>
                <li> 1. glDeleteBuffersARB(1,&nVBOVertices); //删除句柄，同时删除server端顶点缓冲</li>
            </ul>


            <hr>
            <p>
                再来看看纹理缓冲是怎么使用的，其实差不多：
            </p>
            <p>
                初始化阶段：
            </p>
            <ul>
                <li> 1. glGenTextures(1, &texID);//创建句柄</li>
                <li> 2. glBindTexture(GL_TEXTURE_2D, texID); //设置句柄类型</li>
                <li>
                    3. glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img->GetWidth(), img->GetHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, raw_rgba);
                    //上传纹理缓冲
                </li>
            </ul>
</div>
</body>
</html>