<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="mariaclark1123@outlook.com"><title>C++详解预处理 · Fang-da</title><meta name="description" content="C/C++编译系统编译程序的过程为预处理、编译、链接。预处理器是在程序源文件被编译之前根据预处理指令对程序源文件进行处理的程序。预处理器指令以#号开头标识，末尾不包含分号。预处理命令不是C/C++语言本身的组成部分，不能直接对它们进行编译和链接。C/C++语言的一个重要功能是可以使用预处理指令和具有"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/judy.jpg" style="width:160px;"><h3 title=""><a href="/" style="font-family:medium-ui-sans-serif-text-font,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,Roboto,Oxygen,Ubuntu,Cantarell,&quot;Open Sans&quot;,&quot;Helvetica Neue&quot;,sans-serif;">Fang-da</a></h3><div class="description"><p>生活一分一秒的过, 你的斗志不是燃烧一刻，而是要每分每秒的燃烧, 即使不燃烧，至少不能让它熄灭。你要的斗志从来都不在逆境中, 而在你做成一件事后这件事能给你带来的成就感以及未来, 那是能指导你每分每秒都燃烧的火药。</p></div></div></div><ul class="social-links"><li><a href="http://facebook.com/mariaclark1123"><i class="fa fa-facebook"></i></a></li><li><a href="http://github.com/mariaclark1123"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"></a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Theme from Fangda&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/albums">相册</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>C++详解预处理</a></h3></div><div class="post-content"><p>C/C++编译系统编译程序的过程为预处理、编译、链接。<br>预处理器是在程序源文件被编译之前根据预处理指令对程序源文件进行处理的程序。预处理器指令以#号开头标识，末尾不包含分号。预处理命令不是C/C++语言本身的组成部分，不能直接对它们进行编译和链接。C/C++语言的一个重要功能是可以使用预处理指令和具有预处理的功能。C/C++提供的预处理功能主要有文件包含、宏替换、条件编译等。  </p>
<h3 id="1、文件包含"><a href="#1、文件包含" class="headerlink" title="1、文件包含"></a>1、文件包含</h3><p>预处理指令#include用于包含头文件，有两种形式：#include <xxx.h>，#include “xxx.h”。<br>尖括号形式表示被包含的文件在<strong>系统目录</strong>中。如果被包含的文件不一定在系统目录中，应该用双引号形式。<br>在双引号形式中可以指出文件路径和文件名。如果在双引号中没有给出绝对路径，则默认为用户当前目录中的文件，此时系统首先在用户当前目录中寻找要包含的文件，若找不到再在系统目录中查找。<br>对于用户自己编写的头文件，宜用双引号形式。对于系统提供的头文件，既可以用尖括号形式，也可以用双引号形式，都能找到被包含的文件，但显然用尖括号形式更直截了当，效率更高。<br><strong>./表示当前目录，../表示当前目录的父目录。</strong>  </xxx.h></p>
<h3 id="2、宏替换"><a href="#2、宏替换" class="headerlink" title="2、宏替换"></a>2、宏替换</h3><h6 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h6><p>宏定义的作用一般是用一个短的名字代表一个长的代码序列。宏定义包括无参数宏定义和带参数宏定义两类。宏名和宏参数所代表的代码序列可以是任何意义的内容，如类型、常量、变量、操作符、表达式、语句、函数、代码块等。但要尤其注意的是宏名和宏参数必须是合法的标识符，其所代表的内容及意义在宏展开前后必须一直是独立且保持不变的，不能分开解释和执行。<br><strong>无参数宏定义</strong>：用一个用户指定的称为宏名的标识符来代表一个代码序列，这种定义的一般形式为#define 标识符 代码序列。其中#define之后的标识符称为宏定义名（简称宏名），在宏定义#define之前可以有若干个空格、制表符，但不允许有其它字符，宏名与代码序列之间用空格符分隔。<br><strong>带参数宏定义</strong>：带参数宏定义进一步扩充了无参数宏定义的能力，这时的宏展开既进行宏名的替换又进行宏参数的替换。带参数的宏定义的一般形式为#define 标识符(参数表) 代码序列，其中参数表中的参数之间用逗号分隔，在代码序列中必须要包含参数表中的的参数。在定义带参数的宏时，宏名与左圆括号之间不允许有空白符，应紧接在一起，否则变成了无参数的宏定义。带参数宏调用提供的实在参数个数必须与宏定义中的形式参数个数相同。<br>宏定义的有效范围称为宏名的作用域，宏名的作用域从宏定义的结束处开始到其所在的源代码文件末尾。宏名的作用域不受分程序结构的影响。如果需要终止宏名的作用域，可以用预处理指令#undef加上宏名。<br>宏名一般用大写字母，以便与变量名区别。如有必要，宏名可被重复定义，被重复定义后，宏名原先的意义被新意义所代替。<br>宏定义代码序列中必须把””配对，不能把字符串””拆开。例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"           //vrmozart不合法</span></span></div><div class="line"><span class="meta"><span class="meta-string">#define NAME "</span>vrmozart<span class="meta-string">"  //合法</span></span></div></pre></td></tr></table></figure></p>
<p>宏定义代码序列中可以引用已经定义的宏名，即宏定义可以嵌套。</p>
<h6 id="多行宏"><a href="#多行宏" class="headerlink" title="多行宏"></a>多行宏</h6><p>宏定义在源文件中必须单独另起一行，换行符是宏定义的结束标志，因此宏定义以换行结束，不需要分号等符号作分隔符。如果一个宏定义中代码序列太长，一行不够时，可采用续行的方法。续行是在键入回车符之前先键入符号\，注意回车要紧接在符号\之后，中间不能插入其它符号，当然代码序列最后一行结束时不能有\。注意多行宏在调用时只能单独一行调用，不能用在表达式中或作为函数参数。  </p>
<h6 id="宏展开"><a href="#宏展开" class="headerlink" title="宏展开"></a>宏展开</h6><p>预处理器在处理宏定义时，会对宏进行展开（即宏替换）。宏替换首先将源文件中在宏定义随后所有出现的宏名均用其所代表的代码序列替换之，如果是带参数宏则接着将代码序列中的宏形参名替换为宏实参名。宏替换只作代码字符序列的替换工作，不作任何语法的检查，也不作任何的中间计算，一切其它操作都要在替换完后才能进行。如果宏定义不当，错误要到预处理之后的编译阶段才能发现。<br>源代码中的宏名和宏定义代码序列中的宏形参名必须是标识符才会被替换，即只替换标识符，不替换别的东西，像注释、字符串常量以及标识符内出现的宏名或宏形参名则不会被替换。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME vrmozart  <span class="comment">//源代码//NAME、/*NAME*/、"NAME"、my_NAME_blog中的宏名NAME都不会被替换。</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOG(name) my_name_blog=<span class="meta-string">"name"</span> <span class="comment">//宏定义代码序列中的宏形参名name也都不会被替换</span></span></div></pre></td></tr></table></figure></p>
<p>如果希望宏定义代码序列中标识符内出现的宏形参名能够被替换，可以在宏形参名与标识符之间添加连接符##，在宏替换过程中宏形参名和连接符##一起将被替换为宏实参名。##用于把宏参数名与宏定义代码序列中的标识符连接在一起，形成一个新的标识符。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOG(name) my_##name        <span class="comment">//BLOG(vrmozart)表示my_vrmozart</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOG(name) name##_ blog     <span class="comment">//BLOG(vrmozart)表示vrmozart_ blog</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOG(name) my_##name##_blog <span class="comment">//BLOG(vrmozart)表示my_vrmozart_ blog</span></span></div></pre></td></tr></table></figure></p>
<p>如果希望宏定义代码序列中的宏形参名被替换为宏实参名的字符串形式（即在宏实参名两端加双引号”），而不是替换为宏实参名，可以在宏定义代码序列中的宏形参名前面添加符号#。#用于把宏参数名变为一个字符串形式。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(name) #vrmozart  <span class="comment">//STR(vrmozart)表示"vrmozart"</span></span></div></pre></td></tr></table></figure></p>
<p>当宏参数是另一个宏的时候，需要注意的是宏定义代码序列中有用#或##的宏参数是不会再展开。</p>
<h6 id="宏的独立性"><a href="#宏的独立性" class="headerlink" title="宏的独立性"></a>宏的独立性</h6><p>在宏定义中说过，宏名和宏形参名所代表的内容及意义在宏展开前后必须一直是独立且保持不变的，不能分开解释和执行。其原因如下，在宏调用时，用宏定义的代码序列替换宏名，用宏实参名替换宏形参名。替换后，宏定义的代码序列就与源文件中相邻的代码自然连接，宏实参名也与代码序列中相邻的代码自然连接，宏定义的代码序列和宏实参名的独立性就不一定依旧存在。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SQR(x) x*x  <span class="comment">//希望实现表达式的平方计算。</span></span></div><div class="line">p＝SQR(y)     <span class="comment">//宏展开p=y*y</span></div><div class="line">q＝SQR(u＋v)  <span class="comment">//得到的宏展开是q＝u＋v*u＋v</span></div></pre></td></tr></table></figure></p>
<p>显然，后者的展开结果不是程序设计者所希望的。为能保持宏实参名替换后的独立性，应在宏定义中给形式参数加上括号。进一步，为了保证宏名调用的独立性，作为算式的宏定义代码序列也应加括号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SQR(x) ((x)*(x))  <span class="comment">//正确的宏定义。</span></span></div></pre></td></tr></table></figure></p>
<h6 id="宏调用与函数调用的区别"><a href="#宏调用与函数调用的区别" class="headerlink" title="宏调用与函数调用的区别"></a>宏调用与函数调用的区别</h6><p>函数调用在程序运行时实行，而宏展开是在编译的预处理阶段进行；<br>函数调用占用程序运行时间，宏调用只占编译时间；<br>函数调用对实参有类型要求，而宏调用实在参数与宏定义形式参数之间没有类型的概念，只有字符序列的对应关系；<br>函数调用可返回一个值，宏调用获得希望的代码序列。<br>另外，函数调用时，实参表达式分别独立求值在前，执行函数体在后.宏调用是实在参数字符序列替换形式参数。</p>
<h6 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h6><p>__DATE<strong>，字符串常量类型，表示当前所在源文件的编译日期，输出格式为Mmm dd yyyy（如May 27 2006）。<br>__TIME</strong>，字符串常量类型，表示当前所在源文件的编译日期，输出格式为hh:mm:ss（如09:11:10）。<br>__FILE<strong>，字符串常量类型，表示当前所在源文件名，且包含文件路径。<br>__LINE</strong>，整数常量类型，表示当前所在源文件中的行号。<br>__FUNCTION__，字符串常量类型，表示当前所在函数名。<br>这些预定义宏在调试程序时是很有用的，因为你可以很容易的知道程序运行到了那个文件的那一行，是那个函数。<br>用户除了可以在源文件的开头使用#define定义宏外，还可在编译器项目属性“预处理器”属性页定义宏。这种宏定义方式支持数字和字符串，一般形式为：标识符=数字或字符串常量，如果省略=以及后面的内容，则宏名标识符默认为整数1。定义宏的方法是在“预处理器定义”属性输入宏定义内容，多个宏定义之间用分号隔开。“预处理器定义”中的宏定义要先于源文件中的宏定义被处理，其有效范围为整个项目，除非在源文件中遇到重定义或用 #undef 指定取消宏定义名，否则该宏定义名在源文件中一直保持有效。  </p>
<h3 id="3、条件编译指令"><a href="#3、条件编译指令" class="headerlink" title="3、条件编译指令"></a>3、条件编译指令</h3><p> 一般情况下，在进行编译时对源程序中的每一行都要编译，但是有时希望程序中某一部分内容只在满足一定条件时才进行编译，如果不满足这个条件，就不编译这部分内容，这就是条件编译。条件编译主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到多个版本控制、防止对文件重复包含的功能。#if,#ifndef,#ifdef,#else,#elif,#endif是比较常见条件编译预处理指令，可根据表达式的值或某个特定宏是否被定义来确定编译条件。</p>
<h6 id="指令意义"><a href="#指令意义" class="headerlink" title="指令意义"></a>指令意义</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span>       <span class="comment">//表达式非零就对代码进行编译；</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>    <span class="comment">//如果宏被定义就进行编译；</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>   <span class="comment">//如果宏未被定义就进行编译；</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span>     <span class="comment">//作为其它预处理的剩余选项进行编译；</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span>     <span class="comment">//这是一种#else和#if的组合选项；</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>    <span class="comment">//结束编译块的控制。</span></span></div></pre></td></tr></table></figure>
<h6 id="常用形式"><a href="#常用形式" class="headerlink" title="常用形式"></a>常用形式</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #if_#endif形式：</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 常数表达式 或 #<span class="meta-keyword">ifdef</span> 宏名 或 #<span class="meta-keyword">ifndef</span> 宏名</span></div><div class="line">  <span class="comment">// 程序段</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>如果常数表达式为真或者该宏名已定义或者该宏名未定义，则编译后面的程序段；否则就不编译，跳过这段程序。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #if_#else_#endif形式：</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 常量表达式 或 #<span class="meta-keyword">ifdef</span> 宏名 或 #<span class="meta-keyword">ifndef</span> 宏名</span></div><div class="line">   <span class="comment">// 程序段1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">   <span class="comment">// 程序段2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>如果常数表达式为真或者该宏名已定义或者该宏名未定义，则编译后面的程序段1；否则编译后面的程序段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #if_#elif_#endif形式：</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 常量表达式1</span></div><div class="line">  <span class="comment">// 程序段1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> 常量表达式2</span></div><div class="line">  <span class="comment">// 程序段2</span></div><div class="line">  <span class="comment">// .......</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> 常量表达式n</span></div><div class="line">  <span class="comment">// 程序段n</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>注意这种形式#elif不可以用于#ifdef和#ifndef中，但#else可以。</p>
<h6 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h6><p>预处理器表达式包括的操作符主要涉及到单个数的操作（+、-、~、&lt;&lt;、&gt;&gt;）、多个数的运算（*、/、%、+、-、&amp;、^、|）、关系比较（&lt;、&lt;=、&gt;、&gt;=、==、!=）、宏定义判断（defined）、逻辑操作（!、&amp;&amp;、||），其优先级和行为方式与C++表达式操作符相同。对于预处理器表达式，一定要记住它们是在编译器预处理器上执行的，是在编译前进行的。<br>例子：#ifndef 与#if !defined意义相同，#ifdef 与#if defined意义相同。</p>
<h3 id="4、其它预处理指令"><a href="#4、其它预处理指令" class="headerlink" title="4、其它预处理指令"></a>4、其它预处理指令</h3><p>除了上面讨论的常用预处理指令外，还有三个不太常见的预处理指令：#line、#error、#pragma，下面分别介绍。<br><strong>#line</strong><br>#line指令用于重新设定当前由__FILE__和__LINE__宏指定的源文件名字和行号。<br>#line一般形式为#line number “filename”，其中行号number为任何正整数，文件名filename可选。#line主要用于调试及其它特殊应用，注意在#line后面指定的行号数字是表示从下一行开始的行号。<br><strong>#error</strong><br>#error指令使预处理器发出一条错误消息，然后停止执行预处理。<br>#error 一般形式为#error info，如#error MFC requires C++ compilation。<br><strong>#pragma</strong><br>#pragma指令可能是最复杂的预处理指令，它的作用是设定编译器的状态或指示编译器完成一些特定的动作。<br>#pragma一般形式为#pragma para，其中para为参数，下面介绍一些常用的参数。<br>#pragma once，只要在头文件的最开始加入这条指令就能够保证头文件被编译一次。<br>#pragma message(“info”)，在编译信息输出窗口中输出相应的信息，例如#pragma message(“Hello”)。<br>#pragma warning，设置编译器处理编译警告信息的方式，例如#pragma warning(disable:4507 34;once : 4385;error:164)等价于#pragma warning(disable:4507 34)（不显示4507和34号警告信息）、#pragma warning(once:4385)（4385号警告信息仅报告一次）、#pragma warning(error:164)（把164号警告信息作为一个错误）。<br>#pragma comment(…)，设置一个注释记录到对象文件或者可执行文件中。常用lib注释类型，用来将一个库文件链接到目标文件中，一般形式为#pragma comment(lib,”*.lib”)，其作用与在项目属性链接器“附加依赖项”中输入库文件的效果相同。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-17</span><i class="fa fa-tag"></i><a href="/tags/C/" title="C++" class="tag">C++ </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2018/03/17/C-详解预处理/,Fang-da,C++详解预处理,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2018/03/17/VS2017-配置glut-glew-glfw-glad最简单的方法/" title="VS2017 配置glut, glew, glfw, glad最简单的方法" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2018/03/17/强大的C-矩阵处理库-Eigen/" title="强大的C++矩阵处理库-Eigen" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>