<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <title>OpenGL - FBO</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        /** {padding:0;margin:0;}
html, body {width:100%;height:100%;}
.container {width:960px;margin:0 auto;}*/
    </style>
</head>

<body>
    <div class="container">
        <hr>
        <h1>OpenGL - FBO</h1>
        <hr>
        <br>
        <h3>Frame Buffer Object (FBO)</h3>
        <p style="color:red;"> - Allows rendered contents (color, depth, stencil(模板)) to be stored in non-displayable framebuffers (e.g., texture object, renderbuffer object)</p>
        <p style="color:red;"> - GL_EXT_framebuffer_object</p>
        <br>
        <p>在OpenGL渲染流水线上，几何数据和纹理数据被多次转换、多次测试，最后以2维像素的形式显示在屏幕上。而OpenGL流水线上最后显示阶段像素所在处，称为帧缓存。帧缓存可视为2维数组，或OpenGL使用的存储区域，它包括了：颜色缓存、深度缓存、模板缓存和累积缓存。</p>
        <p>一般情况下，帧缓存由window系统生成并管理，供OpenGL使用。这种缺省的帧缓存称之为“window系统生成”（window-system-provided）的帧缓存。
在OpenGL扩展中，GL_EXT_framebuffer_object提供了另外一种不能够显示的帧缓存接口，帧缓存对象（FBO）。这种帧缓存称之为“应用生成”帧缓存，以区别于“window系统生成”帧缓存。通过使用帧缓存对象（FBO），OpenGL应用程序可以将显示内容输出到“应用生成”帧缓存，而不是传统的“window系统生成”帧缓存。这个过程全部由OpenGL控制。和window系统提供的帧缓存一样，FBO也有一组相应存储颜色、深度和模板（注意没有累积）数据的缓存区域。我们把FBO中存储这些数据的区域称之为“缓存关联图像”（framebuffer-attached image）。它完全由OpenGL管理控制。</p>
<p>缓存关联图像分为两类：纹理缓存和渲染（显示）缓存（renderbuffer）。如果纹理对象的图像数据关联到帧缓存，opengl执行的将是“渲染到纹理”（render to texture）操作。如果渲染缓存对象的图像数据关联到帧缓存，opengl执行的将是“离线渲染”（offscreen rendering）。渲染缓存对象是GL_EXT_framebuffer_object中定义的新的一种存储类型。这用于渲染过程中存储单幅2维图像。下面的图1描述了FBO、纹理对象和渲染缓存对象之间的关系。</p>
<br>
<br>
<br>
<img align=left src="fbo1.jpg">
<p>
从图中可以看出，FBO有多个颜色关联：(GL_COLOR_ATTACHMENT0_EXT,..., GL_COLOR_ATTACHMENTn_EXT), 一个深度关联(GL_DEPTH_ATTACHMENT_EXT)和一个模板关联 (GL_STENCIL_ATTACHMENT_EXT)。颜色关联的数目最少有一个，最大数目是与实体的显卡相关的，可以GL_MAX_COLOR_ATTACHMENTS_EXT查询得到。FBO采用多个颜色关联，这样可以同时将多个颜色缓存渲染（绘制）到多个FBO关联存储区，即“多渲染目标”MRT（multiple render target）。MRT可用GL_ARB_draw_buffers完成。<p>
<p style="color:red;">注意：FBO本身并没有图像数据存储区，只有多个关联。</p>
<br>
<p> FBO提供了一种高效的切换机制：将前一个帧缓存关联图像从FBO分离，将一个新的可关联帧缓存图像与FBO关联。FBO对帧缓存关联图像的切换要比对FBO的切换速度更快。用glFramebufferTexture2DEXT()，可以进行二维纹理对象的切换，用glFramebufferRenderbufferEXT可切换渲染缓存对象。</p>
        <hr>
        <br>
        <p>
            ...Be continued
        </p>
            
        <hr>
        <br>
        <h3>参考文章</h3>
        <ul>
            <li><a href="http://http://www.gamedev.net/reference/articles/article2331.asp"> OpenGL Frame Buffer Object 101 </a></li>
            <li><a href="http://developer.zhiding.cn/2008/0703/963021.shtml"> GPU编程示例一 Render to Vertexbuffer in OpenGL</a></li>
            <li><a href="http://www.songho.ca/opengl/gl_fbo.html"> OpenGL Frame Buffer Object (FBO)</a></li>
        </ul>

        <hr>
        <br>
        <p><a href="http://blog.sina.com.cn/s/blog_4062094e0100alvv.html">本文转自保持快乐保持健康博客博客：http://blog.sina.com.cn/s/blog_4062094e0100alvv.html</a></p>
    </div>
</body>
<script src="js/js.js"></script>
</html>
